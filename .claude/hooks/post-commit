#!/bin/bash
# post-commit hook
# Automatically record work history to Notion after each commit
# This hook runs after a successful commit

set -e

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Get repository root
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || echo ".")"
SESSION_FILE="${REPO_ROOT}/.claude/cache/current-notion-page.txt"
CONTEXT_FILE="${REPO_ROOT}/.claude/cache/current-workflow-context.json"

# Source work history library
WORK_HISTORY_LIB="${REPO_ROOT}/.claude/lib/notion-work-history.sh"

# Check if session file exists
if [[ ! -f "$SESSION_FILE" ]]; then
    echo -e "${BLUE}â„¹ï¸  No active Notion session - work history recording skipped${NC}"
    exit 0
fi

# Read page ID from session file
PAGE_ID=$(cat "$SESSION_FILE" 2>/dev/null | tr -d '[:space:]')
if [[ -z "$PAGE_ID" ]]; then
    echo -e "${YELLOW}âš ï¸  Session file is empty - work history recording skipped${NC}"
    exit 0
fi

# Get current commit hash
COMMIT_HASH=$(git rev-parse HEAD 2>/dev/null)
if [[ -z "$COMMIT_HASH" ]]; then
    echo -e "${RED}âŒ Failed to get commit hash${NC}" >&2
    # Don't fail the commit
    exit 0
fi

# Load workflow context if exists
CONTEXT=""
if [[ -f "$CONTEXT_FILE" ]]; then
    CONTEXT=$(cat "$CONTEXT_FILE" 2>/dev/null || echo "")
fi

# Get commit message and date
COMMIT_MSG=$(git log -1 --format=%B "$COMMIT_HASH" 2>/dev/null)
COMMIT_DATE=$(TZ='Asia/Seoul' git log -1 --format=%cd --date=format:'%Y-%m-%d' "$COMMIT_HASH" 2>/dev/null)
COMMIT_AUTHOR=$(git log -1 --format=%an "$COMMIT_HASH" 2>/dev/null)

# Get commit time (KST)
COMMIT_TIME=$(TZ='Asia/Seoul' git log -1 --format=%cd --date=format:'%H:%M' "$COMMIT_HASH" 2>/dev/null)

# Get changed files
FILE_LIST=$(git diff-tree --no-commit-id --name-only -r "$COMMIT_HASH" 2>/dev/null | tr '\n' '|')

# Get diff stats
STATS=$(git diff --stat HEAD~1..HEAD 2>/dev/null || echo "")
FILES_CHANGED=$(echo "$STATS" | tail -1 | awk '{print $1}' 2>/dev/null || echo "0")
INSERTIONS=$(echo "$STATS" | tail -1 | grep -oE '[0-9]+ insertion' | awk '{print $1}' 2>/dev/null || echo "0")
DELETIONS=$(echo "$STATS" | tail -1 | grep -oE '[0-9]+ deletion' | awk '{print $1}' 2>/dev/null || echo "0")

# Ensure numeric variables have default values
FILES_CHANGED="${FILES_CHANGED:-0}"
INSERTIONS="${INSERTIONS:-0}"
DELETIONS="${DELETIONS:-0}"

# Extract work type
if [[ -f "${WORK_HISTORY_LIB}" ]]; then
    source "${WORK_HISTORY_LIB}"
    WORK_TYPE=$(extract_work_type "$COMMIT_MSG" 2>/dev/null || echo "ê¸°íƒ€")
else
    WORK_TYPE="ê¸°íƒ€"
fi

# Create pending commits file if not exists
PENDING_FILE="${REPO_ROOT}/.claude/cache/pending-commits.json"
mkdir -p "$(dirname "$PENDING_FILE")"

# Initialize pending commits array if file doesn't exist
if [[ ! -f "$PENDING_FILE" ]]; then
    echo "[]" > "$PENDING_FILE"
fi

# Add commit to pending list
TEMP_FILE=$(mktemp)
python3 -c "
import json
import sys

# Read existing pending commits
try:
    with open('$PENDING_FILE', 'r') as f:
        pending = json.load(f)
except:
    pending = []

# Add new commit
new_commit = {
    'page_id': '$PAGE_ID',
    'commit_hash': '$COMMIT_HASH',
    'commit_msg': '''$COMMIT_MSG''',
    'commit_date': '$COMMIT_DATE',
    'commit_time': '$COMMIT_TIME',
    'commit_author': '$COMMIT_AUTHOR',
    'files_changed': int('$FILES_CHANGED' or 0),
    'insertions': int('$INSERTIONS' or 0),
    'deletions': int('$DELETIONS' or 0),
    'file_list': '$FILE_LIST'.split('|') if '$FILE_LIST' else [],
    'work_type': '$WORK_TYPE',
    'context': '$CONTEXT' if '$CONTEXT' else None
}

pending.append(new_commit)

# Write back
with open('$TEMP_FILE', 'w') as f:
    json.dump(pending, f, ensure_ascii=False, indent=2)

print(f'Added commit {new_commit[\"commit_hash\"][:7]} to pending list')
" && mv "$TEMP_FILE" "$PENDING_FILE"

echo -e "${BLUE}ğŸ“ Commit queued for Notion sync${NC}"
echo -e "${GREEN}âœ… ì‘ì—…ë‚´ì—­ì€ ë‹¤ìŒ Claude ì‹¤í–‰ ì‹œ Notionì— ìë™ ê¸°ë¡ë©ë‹ˆë‹¤${NC}"
echo -e "${BLUE}ğŸ’¡ ìˆ˜ë™ ë™ê¸°í™”: Notion í˜ì´ì§€ë¥¼ fetchí•˜ë©´ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤${NC}"

# Always exit successfully to preserve the commit
exit 0
