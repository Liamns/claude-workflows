---
name: commit
description: Git 변경사항을 분석하여 Conventional Commits 형식으로 커밋 메시지를 자동 생성하고 커밋합니다
---

# 🚀 Smart Commit Command

Git 변경사항을 자동으로 분석하여 Conventional Commits 형식의 커밋 메시지를 생성하고 커밋합니다.

## 사용법

```bash
/commit              # 변경사항 분석 후 확인 단계를 거쳐 커밋 (기본)
/commit --force      # 확인 없이 바로 커밋 (긴급 상황용)
/commit --no-verify  # 검증 없이 빠른 커밋
/commit "컨텍스트"   # 추가 컨텍스트와 함께 커밋
```

**--force 옵션**:
- 확인 단계(Step 5)를 건너뜁니다
- 긴급 상황이나 CI/CD에서 유용합니다
- 주의: 실수 가능성이 있으므로 신중히 사용하세요

## 프로세스

### Step 0: 명령어 인자 파싱

/commit 명령어의 인자를 파싱합니다:

```javascript
// 사용자 입력: /commit --force
const args = parseCommandArgs();
const has_force_flag = args.includes('--force');
```

파싱 결과:
- has_force_flag = true → Step 5 건너뛰기
- has_force_flag = false → 정상 프로세스 진행

### Step 1: 변경사항 분석
```bash
git status  # 변경된 파일 목록 확인
git diff    # 상세 변경 내용 분석
```

### Step 1.5: Feature ID 자동 감지 (Epic 워크플로우)

**Bash 도구로 Feature ID 감지**:
```
Bash:
- command: "FEATURE_ID=''; if [ -f spec.md ]; then FEATURE_ID=$(grep '^- Feature ID:' spec.md | awk '{print $4}'); fi; echo $FEATURE_ID"
- description: "Detect Feature ID from spec.md if exists"
```

Feature ID가 감지되면 `{featureId}` 변수에 저장하세요 (예: "001").
Feature ID가 없으면 `{featureId}` 는 빈 문자열입니다.

**Note**: 이 단계는 Epic 워크플로우 내부의 Feature에서만 작동합니다. 독립 Feature에는 spec.md가 없거나 Feature ID 필드가 없을 수 있습니다.

### Step 2: smart-committer Agent 활성화
복잡한 변경사항 분석을 위해 전문 Agent를 활성화합니다:
- 다중 파일 변경 시 카테고리별 분류
- 변경 유형 자동 판단 (feat/fix/refactor 등)
- Breaking Changes 감지

### Step 3: 커밋 메시지 생성

#### Conventional Commits 형식
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

#### 타입 분류 기준
- **feat**: 새로운 기능 추가
- **fix**: 버그 수정
- **refactor**: 코드 리팩토링 (기능 변경 없음)
- **style**: 코드 포맷팅, 세미콜론 누락 등
- **docs**: 문서 수정
- **test**: 테스트 추가 또는 수정
- **chore**: 빌드 프로세스, 도구 설정 변경
- **perf**: 성능 개선
- **ci**: CI 설정 변경
- **build**: 빌드 시스템 또는 외부 종속성 변경
- **revert**: 이전 커밋 되돌리기

#### 스코프 자동 감지
```javascript
// 파일 경로에서 스코프 추출
src/features/order/... → feat(order): ...
src/shared/ui/...     → style(ui): ...
src/entities/user/... → refactor(user): ...
```

### Step 4: 선택적 검증 (commit-guard)

```markdown
📋 커밋 전 검증을 실행하시겠습니까?

[1] Full Check - 타입체크 + 테스트 + 린트
[2] Quick Check - 타입체크만
[3] Skip - 검증 건너뛰기

선택: _
```

검증 옵션:
- **타입 체크**: `yarn type-check`
- **관련 테스트**: 변경된 파일의 테스트만 실행
- **린트**: `yarn lint` (선택사항)
- **민감 정보 검사**: .env, API 키 등 확인

### Step 4.5: --force 플래그 분기 처리

Step 4 (커밋 메시지 생성 및 검증) 완료 후, --force 플래그 확인:

```javascript
if (has_force_flag) {
  // Step 5 건너뛰기
  console.log("⚡ --force 옵션으로 확인 없이 커밋 실행");
  // 바로 Step 6으로 이동
} else {
  // Step 5 (확인 단계) 실행
}
```

### Step 5: 커밋 메시지 확인 및 수정

**Step 5 진입 전 초기화**:

Step 5에 처음 진입할 때 다음 변수를 초기화하세요:
```javascript
let edit_count = 0;  // 메시지 수정 횟수 추적
```

📝 생성된 커밋 메시지를 표시한 후, **AskUserQuestion 도구를 사용**하여 사용자 확인을 받습니다.

**AskUserQuestion 호출**:

다음과 같이 AskUserQuestion 도구를 호출하세요:

```
AskUserQuestion({
  questions: [{
    question: "다음 커밋 메시지로 커밋하시겠습니까?\n\n" + generated_message,
    header: "커밋 확인",
    multiSelect: false,
    options: [
      {
        label: "커밋 실행",
        description: "이 메시지로 커밋합니다"
      },
      {
        label: "메시지 수정",
        description: "커밋 메시지를 수정합니다"
      },
      {
        label: "취소",
        description: "커밋하지 않습니다"
      }
    ]
  }]
})
```

**각 옵션 처리**:

#### Option 1: "커밋 실행" 선택

사용자가 "커밋 실행"을 선택한 경우:
1. generated_message를 final_message로 설정
2. Step 6 (Git Commit 실행)으로 이동

#### Option 2: "메시지 수정" 선택

사용자가 "메시지 수정"을 선택한 경우:

1. edit_count 변수 증가 (최초 0에서 시작)
2. edit_count > 3인지 확인:
   - Yes → 에러 메시지 출력 후 종료:
     ```
     ❌ 최대 메시지 수정 횟수(3회)를 초과했습니다.

     처음부터 다시 시작하려면 /commit을 다시 실행하세요.
     ```
   - No → 다음 단계 진행

3. AskUserQuestion으로 수정된 메시지 입력 받기:
   ```
   AskUserQuestion({
     questions: [{
       question: "수정할 커밋 메시지를 입력하세요:\n\n기존 메시지:\n" + generated_message,
       header: "메시지 수정",
       multiSelect: false,
       options: [
         {
           label: "직접 입력하겠습니다",
           description: "Other 옵션으로 새 메시지 입력"
         }
       ]
     }]
   })
   ```

4. 사용자가 입력한 메시지를 new_message로 저장
5. generated_message = new_message로 업데이트
6. **Step 5로 다시 돌아가기** (재귀적 확인)

#### Option 3: "취소" 선택

사용자가 "취소"를 선택한 경우:
1. 다음 메시지 출력:
   ```
   ❌ 커밋이 취소되었습니다.

   Staged 파일은 그대로 유지됩니다.
   다시 커밋하려면 /commit을 실행하세요.
   ```
2. 워크플로우 종료 (Step 6으로 이동하지 않음)

### Step 6: 커밋 실행

**Feature ID 태그 추가 (Epic 워크플로우)**:

Step 1.5에서 감지한 `{featureId}` 값이 있으면 커밋 메시지에 `[F{featureId}]` 태그를 추가합니다.

**Bash 도구로 커밋 실행 (Feature ID 있으면)**:
```
Bash (조건부 - {featureId}가 비어있지 않으면):
- command: "git commit -m \"$(cat <<'EOF'
[F{featureId}] {final_message}

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)\""
- description: "Commit with Feature ID tag"
```

**Bash 도구로 커밋 실행 (Feature ID 없으면)**:
```
Bash (조건부 - {featureId}가 비어있으면):
- command: "git commit -m \"$(cat <<'EOF'
{final_message}

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)\""
- description: "Commit without Feature ID tag"
```

**Note**: Epic 워크플로우 내부에서는 자동으로 [F{featureId}] 태그가 추가되어 Git log로 Feature 진행 상황을 추적할 수 있습니다.

## 실제 사용 예시

### 예시 1: 새 기능 추가 (확인 단계 포함)
```bash
/commit

🔍 변경사항 분석 중...

📝 생성된 커밋 메시지:
feat(vehicle): 차량 선택 컴포넌트 구현

┌─────────────────────────────────────┐
│ 커밋 확인                            │
│                                     │
│ [커밋 실행] 이 메시지로 커밋        │
│ [메시지 수정] 커밋 메시지 수정      │
│ [취소] 커밋하지 않음                │
└─────────────────────────────────────┘

"커밋 실행" 선택 →

✅ 커밋이 완료되었습니다!
```

### 예시 2: 버그 수정
```bash
/commit

🔍 변경사항 분석 중...
변경된 파일: 2개
주요 변경: null 체크 추가

📝 생성된 메시지:
fix(order): 주소 정보 null 참조 에러 수정

- Optional chaining 추가
- 기본값 설정

✅ 커밋이 완료되었습니다!
```

### 예시 3: 리팩토링
```bash
/commit --no-verify

🔍 변경사항 분석 중...
변경된 파일: 8개
주요 변경: 공통 로직 추출

📝 생성된 메시지:
refactor: 중복 코드를 유틸 함수로 추출

- formatAddress 함수 생성
- 3개 컴포넌트에서 재사용
- 테스트 커버리지 향상

⚡ 검증 없이 빠른 커밋 실행
✅ 커밋이 완료되었습니다!
```

## 고급 기능

### Breaking Changes 감지
```markdown
⚠️ Breaking Change 감지됨!

- API 응답 형식 변경
- 필수 prop 추가

BREAKING CHANGE 푸터를 추가하시겠습니까? [Y/n]
```

### 다중 타입 변경
```markdown
🔍 여러 타입의 변경이 감지되었습니다:
- 새 기능 (feat): 3개 파일
- 버그 수정 (fix): 1개 파일
- 문서 (docs): 2개 파일

어떻게 처리하시겠습니까?
[1] 개별 커밋으로 분리 (권장)
[2] 주요 타입으로 통합
[3] 수동 선택
```

### 커밋 템플릿
자주 사용하는 패턴을 템플릿으로 저장:
```yaml
templates:
  hotfix: "fix(critical): 긴급 수정 - "
  feature: "feat({scope}): "
  wip: "chore: WIP - "
```

## 설정 옵션

`.claude/commit-config.yaml` (선택사항):
```yaml
# 기본 설정
default_type: feat
auto_scope: true
emoji: false  # 이모지 사용 여부

# 커밋 메세지 설정
commit:
  add_claude_footer: false # "Generated with Claude Code" 푸터 제거

# 검증 기본값
verification:
  default: quick  # full, quick, skip
  auto_fix: true  # 린트 오류 자동 수정

# 커밋 규칙
rules:
  max_length: 72
  require_scope: false
  require_body: false
```

## 통계 및 분석

```markdown
📊 커밋 통계 (최근 30일)

타입별 분포:
• feat: 42 (35%)
• fix: 31 (26%)
• refactor: 18 (15%)
• docs: 12 (10%)
• test: 10 (8%)
• style: 7 (6%)

평균 커밋 메시지 생성 시간: 5초
검증 통과율: 94%
```

## 문제 해결

### "변경사항이 너무 많습니다"
→ 개별 커밋으로 분리하거나 논리적 단위로 스테이징

### "타입을 자동으로 판단할 수 없습니다"
→ 수동으로 타입 선택 또는 추가 컨텍스트 제공

### "검증이 실패했습니다"
→ 오류 내용 확인 후 수정 또는 --no-verify 옵션 사용

## 연동 워크플로우

```bash
# Minor 워크플로우 완료 후 자동 커밋
/minor
→ 작업 완료
→ /commit 자동 실행

# PR 생성 전 커밋
/commit
→ git push
→ /pr-review
```

## ✅ Pre-commit Validation Hook

### 자동 Validation
`.claude/` 디렉토리의 변경사항이 있을 때 자동으로 검증합니다.

```bash
# Hook 설치 (한 번만)
bash .claude/hooks/install-hooks.sh

# 이후 커밋 시 자동 실행
git add .
git commit -m "feat: new feature"

# Hook 동작:
# 1. .claude/ 변경사항 감지
# 2. 문서 검증 실행 (빠른 모드)
# 3. Exit code 0: 커밋 허용
# 4. Exit code 2: 경고 표시하지만 커밋 허용
# 5. Exit code 1: 커밋 차단
```

### Hook 출력 예시
```
🔍 Validating .claude/ changes...
✓ Documentation validation passed (95% consistency)
✓ Cross-reference check passed

Commit allowed.
```

### Validation 실패 시
```
✗ Documentation validation failed (65% consistency)
⚠️ See report: .claude/cache/validation-reports/latest.md

❌ Commit blocked. Please fix validation issues.

Run manual validation:
  bash .claude/lib/validate-system.sh --docs-only
```

### Hook 제거
```bash
# 기존 hook 백업 확인
ls -la .git/hooks/pre-commit.backup.*

# Hook 제거
rm .git/hooks/pre-commit
```

---

💡 **팁**: 자주 커밋하고 작은 단위로 나누면 더 명확한 히스토리를 유지할 수 있습니다. Pre-commit hook은 문서 품질을 자동으로 보장합니다.
