/**
 * {{GatewayName}} API Gateway
 *
 * Microservices Architecture - API Gateway/BFF pattern
 * Routes requests to appropriate microservices
 *
 * @package gateway
 */

import express from 'express';
import { createProxyMiddleware } from 'http-proxy-middleware';

interface ServiceRoute {
  path: string;
  target: string;
  pathRewrite?: Record<string, string>;
  auth?: boolean;
}

export class {{GatewayName}} {
  private app: express.Application;
  private routes: ServiceRoute[];

  constructor() {
    this.app = express();
    this.routes = this.defineRoutes();
    this.setupMiddleware();
    this.setupProxies();
    this.setupErrorHandling();
  }

  private defineRoutes(): ServiceRoute[] {
    return [
      {
        path: '/api/users',
        target: process.env.USER_SERVICE_URL || 'http://localhost:3001',
        pathRewrite: { '^/api/users': '/api/users' },
        auth: true,
      },
      {
        path: '/api/products',
        target: process.env.PRODUCT_SERVICE_URL || 'http://localhost:3002',
        pathRewrite: { '^/api/products': '/api/products' },
        auth: false,
      },
      {
        path: '/api/orders',
        target: process.env.ORDER_SERVICE_URL || 'http://localhost:3003',
        pathRewrite: { '^/api/orders': '/api/orders' },
        auth: true,
      },
    ];
  }

  private setupMiddleware() {
    this.app.use(express.json());

    // CORS
    this.app.use((req, res, next) => {
      res.header('Access-Control-Allow-Origin', '*');
      res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
      if (req.method === 'OPTIONS') {
        return res.sendStatus(200);
      }
      next();
    });

    // Request logging
    this.app.use((req, res, next) => {
      console.log(`[Gateway] ${req.method} ${req.path} -> ${this.findTargetService(req.path)}`);
      next();
    });

    // Rate limiting
    this.setupRateLimiting();
  }

  private setupRateLimiting() {
    // Implementation of rate limiting
    // Can use express-rate-limit or custom implementation
  }

  private setupProxies() {
    this.routes.forEach(route => {
      const proxyOptions = {
        target: route.target,
        changeOrigin: true,
        pathRewrite: route.pathRewrite,
        onProxyReq: (proxyReq: any, req: any, res: any) => {
          // Add custom headers, authentication, etc.
          if (route.auth) {
            const token = req.headers.authorization;
            if (token) {
              proxyReq.setHeader('Authorization', token);
            }
          }

          // Add correlation ID for distributed tracing
          const correlationId = req.headers['x-correlation-id'] || this.generateCorrelationId();
          proxyReq.setHeader('X-Correlation-ID', correlationId);
        },
        onProxyRes: (proxyRes: any, req: any, res: any) => {
          // Log response
          console.log(`[Gateway] ${req.path} responded with ${proxyRes.statusCode}`);
        },
        onError: (err: any, req: any, res: any) => {
          console.error(`[Gateway] Proxy error for ${req.path}:`, err.message);
          res.status(502).json({
            error: 'Bad Gateway',
            message: 'Service temporarily unavailable',
          });
        },
      };

      this.app.use(route.path, createProxyMiddleware(proxyOptions));
    });
  }

  private setupErrorHandling() {
    // 404 handler
    this.app.use((req, res) => {
      res.status(404).json({
        error: 'Not Found',
        message: 'The requested resource does not exist',
      });
    });

    // Global error handler
    this.app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
      console.error('[Gateway] Error:', err);
      res.status(500).json({
        error: 'Internal Server Error',
        message: process.env.NODE_ENV === 'development' ? err.message : 'An error occurred',
      });
    });
  }

  private findTargetService(path: string): string {
    const route = this.routes.find(r => path.startsWith(r.path));
    return route ? route.target : 'unknown';
  }

  private generateCorrelationId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  start(port: number = 8080) {
    this.app.listen(port, () => {
      console.log(`API Gateway listening on port ${port}`);
      console.log('Configured routes:');
      this.routes.forEach(route => {
        console.log(`  ${route.path} -> ${route.target}`);
      });
    });
  }
}

// Bootstrap
const gateway = new {{GatewayName}}();
gateway.start(parseInt(process.env.PORT || '8080'));
