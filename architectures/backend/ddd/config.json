{
  "name": "Domain-Driven Design",
  "type": "backend",
  "version": "1.0.0",
  "description": "Strategic and tactical patterns for complex domain modeling",

  "structure": {
    "directories": {
      "boundedContexts": "Separate bounded contexts",
      "domain": "Core domain model",
      "domain/aggregates": "Aggregate roots and entities",
      "domain/valueObjects": "Value objects",
      "domain/events": "Domain events",
      "domain/services": "Domain services",
      "application": "Application services and use cases",
      "infrastructure": "Technical infrastructure",
      "interfaces": "User interfaces and APIs"
    },
    "namingConventions": {
      "aggregate": "PascalCase",
      "entity": "PascalCase",
      "valueObject": "PascalCase",
      "event": "${Name}Event",
      "repository": "I${Name}Repository",
      "service": "${Name}Service"
    },
    "fileExtensions": {
      "typescript": ["ts"],
      "javascript": ["js"],
      "python": ["py"],
      "java": ["java"],
      "csharp": ["cs"]
    }
  },

  "strategic": {
    "boundedContexts": {
      "description": "Linguistic boundaries within the domain",
      "rules": {
        "autonomy": "Each context is autonomous",
        "explicitBoundaries": "Clear boundaries between contexts",
        "contextMap": "Document relationships between contexts"
      }
    },
    "ubiquitousLanguage": {
      "description": "Shared language between developers and domain experts",
      "rules": {
        "consistency": "Use domain terms consistently",
        "noTechnicalJargon": "Avoid technical terms in domain model",
        "evolution": "Language evolves with understanding"
      }
    },
    "contextMapping": {
      "patterns": [
        "Partnership",
        "Shared Kernel",
        "Customer-Supplier",
        "Conformist",
        "Anticorruption Layer",
        "Open Host Service",
        "Published Language"
      ]
    }
  },

  "tactical": {
    "aggregates": {
      "description": "Consistency boundaries",
      "rules": {
        "consistency": "Ensure transactional consistency within aggregate",
        "identity": "Has unique identity",
        "rootEntity": "Access only through aggregate root",
        "invariants": "Enforce business invariants"
      },
      "example": "Order (root) with OrderItems"
    },
    "entities": {
      "description": "Objects with identity",
      "rules": {
        "identity": "Unique identity throughout lifecycle",
        "mutable": "Can change state",
        "businessLogic": "Contains business behavior"
      }
    },
    "valueObjects": {
      "description": "Objects without identity",
      "rules": {
        "immutable": "Cannot change after creation",
        "equality": "Compared by value",
        "sideEffectFree": "Methods don't modify state"
      },
      "examples": ["Money", "Address", "DateRange"]
    },
    "domainEvents": {
      "description": "Something that happened in the domain",
      "rules": {
        "pastTense": "Named in past tense",
        "immutable": "Cannot be changed",
        "meaningful": "Meaningful to domain experts"
      },
      "examples": ["OrderPlaced", "PaymentReceived", "ShipmentDelivered"]
    },
    "domainServices": {
      "description": "Operations that don't belong to entities",
      "rules": {
        "stateless": "No internal state",
        "domainLogic": "Contains domain logic",
        "namedAfterActivity": "Named after what it does"
      }
    },
    "repositories": {
      "description": "Aggregate persistence abstraction",
      "rules": {
        "aggregateOnly": "One repository per aggregate",
        "inMemorySemantics": "Act like in-memory collections",
        "abstraction": "Hide persistence details"
      }
    },
    "factories": {
      "description": "Complex object creation",
      "rules": {
        "complexity": "Use when creation is complex",
        "invariants": "Ensure valid initial state",
        "abstraction": "Hide creation details"
      }
    },
    "specifications": {
      "description": "Business rules encapsulation",
      "rules": {
        "reusable": "Encapsulate reusable business rules",
        "composable": "Can be combined with other specifications",
        "testable": "Easy to test in isolation"
      }
    }
  },

  "dependencies": {
    "allowed": {
      "interfaces": ["application", "domain"],
      "application": ["domain", "infrastructure"],
      "infrastructure": ["domain"],
      "domain": []
    },
    "forbidden": {
      "domain": ["application", "infrastructure", "interfaces"],
      "boundedContexts": ["otherBoundedContexts"]
    },
    "circular": false
  },

  "qualityRules": {
    "aggregateConsistency": {
      "description": "Maintain consistency within aggregate boundaries",
      "severity": "error"
    },
    "ubiquitousLanguage": {
      "description": "Use domain terms consistently",
      "severity": "warning"
    },
    "boundedContextAutonomy": {
      "description": "Bounded contexts must be autonomous",
      "severity": "error"
    },
    "eventualConsistency": {
      "description": "Use eventual consistency between aggregates",
      "severity": "warning"
    }
  },

  "templates": {
    "aggregate": "architectures/backend/ddd/templates/aggregate.template",
    "entity": "architectures/backend/ddd/templates/entity.template",
    "valueObject": "architectures/backend/ddd/templates/valueObject.template",
    "domainEvent": "architectures/backend/ddd/templates/domainEvent.template",
    "repository": "architectures/backend/ddd/templates/repository.template",
    "domainService": "architectures/backend/ddd/templates/domainService.template"
  }
}