# Research: 문서 및 설치 검증 시스템

> 이 문서는 spec.md의 요구사항을 기반으로 작성되었습니다.
> 참조: [spec.md](./spec.md)

## 요구사항 요약 (from spec.md)

### 문서 검증 (FR-001~004)
- 모든 `.claude/commands/*.md` 파일 파싱 및 워크플로우 추출
- 문서화된 단계를 실제 구현과 비교
- 일관성 백분율 및 상세 불일치 보고
- 문서의 예제 실행 가능 여부 검증

### 마이그레이션 검증 (FR-005~010)
- v1.0 및 v2.4 환경 시뮬레이션 및 v2.5 업그레이드 테스트
- `cleanup_before_migration()` 검증
- 모든 마이그레이션 스크립트 실행 검증
- `detect_installation()` 및 `health_check()` 검증

### 교차 참조 검증 (FR-011~013)
- 마크다운 링크 추출 및 검증
- 에이전트/스킬/템플릿 참조 검증
- 파일 경로 정확성 확인

## 기존 솔루션 분석

### 유사 구현 발견

프로젝트에서 다음 기존 검증 패턴을 발견했습니다:

#### 1. install.sh의 검증 함수들

**발견 위치**: `install.sh:77-140, 412-472, 483-538`

기존 검증 기능:
- `health_check()` (install.sh:77-140): 설치 상태 검증
  - 버전 감지 (detect_installation 호출)
  - 파일 개수 확인 (commands, agents, skills)
  - Deprecated 파일 존재 여부 확인

- `verify_installation()` (install.sh:412-472): 설치 후 무결성 검증
  - 중요 파일 존재 확인
  - 디렉토리 구조 검증
  - 파일 개수 보고

- `validate_installation()` (install.sh:483-538): 설치 완료 후 검증
  - 버전 일치 확인
  - 필수 파일 존재 확인
  - Deprecated 파일 부재 확인

**재사용 가능성**: ⭐⭐⭐⭐⭐
- 이 함수들은 정확히 우리가 필요한 검증 패턴을 제공
- 파일 존재 확인, 버전 검증, deprecated 파일 체크 로직 재사용 가능
- 확장하여 문서 검증 로직 추가 가능

#### 2. 마이그레이션 스크립트 패턴

**발견 위치**:
- `.claude/lib/migrate-v1-to-v2.sh`
- `.claude/lib/migrate-v2-to-v25.sh`

기존 마이그레이션 패턴:
- 버전 감지 및 확인
- 백업 생성
- Deprecated 파일 목록 관리
- 파일 백업 및 제거
- 디렉토리 구조 생성
- 버전 파일 업데이트

**재사용 가능성**: ⭐⭐⭐⭐
- 마이그레이션 시나리오 시뮬레이션에 직접 활용 가능
- 임시 환경 생성 후 이 스크립트들을 실행하여 테스트 가능

#### 3. 문서 구조 패턴

**발견 위치**: `.claude/commands/*.md`

현재 슬래시 명령어 문서 형식:
- 명확한 섹션 구분 (## 사용법, ## 실행 순서, ## Implementation)
- Step 0, Step 1, Step 2 형식의 단계 표시
- 코드 블록 (```bash, ```typescript)
- AskUserQuestion, Bash, Write 등 도구 사용 명시

**재사용 가능성**: ⭐⭐⭐⭐
- grep으로 "### Step" 패턴 추출 가능
- 코드 블록 추출을 위한 패턴 (`^````)
- 도구 사용 검증 (`AskUserQuestion`, `Bash`, `Write`)

### 라이브러리 옵션

| 라이브러리/도구 | 장점 | 단점 | 결정 |
|----------------|------|------|------|
| Bash | 표준 Unix 도구, 의존성 없음 | 복잡한 파싱 어려움 | ✅ 주 도구 |
| grep/sed | 패턴 매칭 빠름, 익숙함 | 복잡한 구조 파싱 불가 | ✅ 문서 파싱 |
| diff | 파일 비교 표준 | 텍스트만 비교 | ✅ 예제 코드 비교 |
| jq | JSON 파싱 우수 | 추가 설치 필요 (선택) | ⚠️ 옵션 |
| markdown parser | 구조화된 파싱 | 복잡도 높음, 의존성 | ❌ 불필요 |
| Python/Node | 스크립팅 강력 | 추가 런타임 필요 | ❌ 제약사항 위반 |

**선택된 스택**:
- Bash 스크립트 (주 언어)
- grep/sed (패턴 매칭)
- diff (내용 비교)
- jq (JSON 보고서 생성, 선택적)

## 기술적 실현 가능성

### 문서 검증 실현 가능성: ⭐⭐⭐⭐ (높음)

**실현 가능한 접근법**:
1. grep으로 "### Step N" 패턴 추출
2. 각 Step의 내용을 코드 블록으로 추출
3. 실제 파일 존재 여부 확인 (예: `.claude/commands/major.md` 존재 확인)
4. 일치율 계산 및 보고

**제한사항**:
- 의미적 일치 검증은 어려움 (문자열 일치로 제한)
- 리팩토링된 코드 감지 불가 (동일 기능, 다른 구현)

**완화 방안**:
- 패턴 매칭을 느슨하게 설정
- 핵심 키워드 기반 검증
- 수동 검토를 위한 불일치 리스트 제공

### 마이그레이션 검증 실현 가능성: ⭐⭐⭐⭐⭐ (매우 높음)

**실현 가능한 접근법**:
1. `mktemp -d`로 임시 디렉토리 생성
2. Git으로 v1.0 또는 v2.4 태그 체크아웃 (또는 파일 복사)
3. `install.sh` 실행 (샌드박스 환경)
4. 결과 검증:
   - 종료 코드 확인
   - 파일 존재 여부 확인
   - 버전 파일 확인
5. 임시 디렉토리 정리

**제한사항**:
- 실제 시스템 변경은 하지 않음 (비파괴적)
- 네트워크 의존성 (GitHub 클론) 필요

**완화 방안**:
- `--dry-run` 모드 우선 구현
- `--integration` 플래그로 실제 실행 옵션 제공
- Git worktree 활용 가능

### 교차 참조 검증 실현 가능성: ⭐⭐⭐⭐ (높음)

**실현 가능한 접근법**:
1. grep으로 마크다운 링크 추출: `\[.*\]\((.*)\)`
2. 상대 경로 해석 및 파일 존재 확인
3. 에이전트/스킬 이름 추출: `/.*agent.*\.md`, `/.*skill.*\.md`
4. 존재하지 않는 참조 리스트 생성

**제한사항**:
- 복잡한 상대 경로 해석 (../../ 등)
- 앵커 링크 검증 어려움 (#section)

**완화 방안**:
- basename으로 파일명 비교
- 앵커 검증은 선택적 기능으로 구현

## 위험 및 완화 방안

| 위험 | 영향도 | 발생 가능성 | 완화 방안 |
|------|--------|-------------|-----------|
| 문서 파싱 실패 (복잡한 구조) | Medium | Medium | 패턴 매칭 단순화, 핵심 패턴만 검증 |
| 마이그레이션 시뮬레이션 실패 (권한 문제) | High | Low | 임시 디렉토리 권한 확인, 사용자 안내 |
| 잘못된 긍정/부정 (false positive/negative) | Medium | Medium | 수동 검토 옵션 제공, 상세 로그 |
| 성능 문제 (대용량 파일) | Low | Low | head/tail로 제한, 병렬 처리 |
| 버전 충돌 (동시 실행) | Medium | Low | 락 파일 사용, 실행 중 체크 |
| Git 의존성 (네트워크) | Medium | Medium | 로컬 파일 백업 사용 옵션 |

## 구현 우선순위

### Phase 1: 기본 검증 (1-2일)
1. 파일 존재 확인
2. 버전 검증
3. Deprecated 파일 체크

### Phase 2: 문서 검증 (2-3일)
1. Step 패턴 추출
2. 코드 블록 추출
3. 일치율 계산

### Phase 3: 마이그레이션 검증 (1-2일)
1. 임시 환경 생성
2. 마이그레이션 스크립트 실행
3. 결과 검증

### Phase 4: 교차 참조 검증 (1일)
1. 마크다운 링크 추출
2. 파일 존재 확인
3. 불일치 보고

### Phase 5: 보고 및 CI/CD (1일)
1. JSON/Markdown 보고서 생성
2. CI/CD 통합 스크립트
3. 자동 정리 로직

## 성공 가능성 평가

**전체 성공 가능성**: ⭐⭐⭐⭐⭐ (95%)

**근거**:
- 기존 검증 함수 재사용 가능 (health_check, verify_installation)
- 단순 패턴 매칭으로 충분 (복잡한 파싱 불필요)
- Bash 스크립트로 모든 요구사항 구현 가능
- 제약사항(표준 Unix 도구만 사용) 준수 가능

**리스크**:
- 문서 구조 변경 시 패턴 업데이트 필요 (5%)
- 예상치 못한 마이그레이션 시나리오 (낮음)

## 다음 단계

1. ✅ 기존 검증 함수 분석 완료
2. ⏭️ 데이터 모델 정의 (data-model.md)
3. ⏭️ 구현 계획 수립 (plan.md)
4. ⏭️ 태스크 분해 (tasks.md)
