---
name: fsd-component-creation
description: FSD 아키텍처 규칙을 준수하는 React 컴포넌트를 자동 생성합니다. 레이어별 템플릿과 규칙에 따라 Entity/Feature/Widget/Page 컴포넌트를 생성하며, 타입 안전성과 Props 규칙을 자동 검증합니다. Major 워크플로우에서 사용됩니다.
allowed-tools: Read, Write, Grep, Glob, Bash(yarn type-check)
---

# FSD Component Creation Skill

FSD(Feature-Sliced Design) 아키텍처 규칙에 따라 컴포넌트를 자동 생성합니다.

## 실행 조건

다음 요청 시 자동으로 실행됩니다:
- "새 컴포넌트 생성"
- "FSD 컴포넌트 추가"
- "Entity/Feature/Widget 만들어줘"
- Major 워크플로우에서 신규 기능 추가

## 생성 프로세스

### Step 1: 레이어 결정

사용자 요청을 분석하여 적절한 FSD 레이어를 결정합니다:

**Entity Layer**:
- 순수한 비즈니스 엔티티 표현
- 데이터 변환 및 포맷팅
- 상태 없는 프레젠테이션
- 예: Order, Payment, Vehicle, User

**Features Layer**:
- 하나의 사용자 액션
- 훅 기반 비즈니스 로직
- 도메인 데이터만 props로 수용
- 예: sign-up, find-id, dispatch-form, payment-process

**Widgets Layer**:
- Features/Entities 조합
- 최소한의 자체 로직
- 독립적인 UI 블록
- 예: header, footer, gnb, order-summary

**Pages Layer**:
- 라우트 핸들러
- Widgets/Features 조합
- 페이지 레벨 로직
- 예: SignUpPage, DashboardPage

### Step 2: Slice 구조 생성

선택된 레이어에 맞는 slice 디렉토리 구조를 생성합니다:

```bash
# Entity 예시: src/entities/vehicle/
entities/vehicle/
├── api/           # (선택) API 호출 함수
├── config/        # (선택) 상수 및 설정
├── model/         # 타입, 스키마, 순수 함수
│   ├── types.ts
│   └── schema.ts
├── lib/           # (선택) 유틸리티 함수
└── ui/            # UI 컴포넌트
    ├── VehicleCard.tsx
    └── VehicleInfo.tsx

# Feature 예시: src/features/dispatch/
features/dispatch/
├── api/           # API 호출
│   ├── createDispatch.ts
│   └── useCreateDispatch.ts
├── config/        # 상수
│   └── constants.ts
├── model/         # 비즈니스 로직, 타입
│   ├── types.ts
│   ├── schema.ts
│   └── useDispatchForm.ts
├── lib/           # 유틸리티
│   └── validators.ts
└── ui/            # UI 컴포넌트
    ├── DispatchForm.tsx
    └── VehicleSelector.tsx
```

### Step 3: 템플릿 적용

레이어별 템플릿을 적용하여 파일을 생성합니다.

#### Entity 템플릿

**model/types.ts**:
```typescript
// Generated by fsd-component-creation skill
export interface {EntityName} {
  id: string;
  // TODO: Add entity properties
}

export interface {EntityName}CardProps {
  data: {EntityName};
  className?: string;
}
```

**model/schema.ts**:
```typescript
// Generated by fsd-component-creation skill
import { z } from 'zod';

export const {entityName}Schema = z.object({
  id: z.string(),
  // TODO: Add schema validation
});

export type {EntityName}Input = z.infer<typeof {entityName}Schema>;
```

**ui/{EntityName}Card.tsx**:
```typescript
// Generated by fsd-component-creation skill
import type { {EntityName}CardProps } from '../model/types';

export function {EntityName}Card({ data, className }: {EntityName}CardProps) {
  return (
    <div className={className}>
      {/* TODO: Implement pure presentational UI */}
      <h3>{data.id}</h3>
    </div>
  );
}
```

#### Feature 템플릿

**model/types.ts**:
```typescript
// Generated by fsd-component-creation skill
export interface {FeatureName}FormData {
  // TODO: Add form fields
}

export interface {FeatureName}Result {
  ok: boolean;
  data?: any;
  error?: string;
}
```

**model/schema.ts**:
```typescript
// Generated by fsd-component-creation skill
import { z } from 'zod';

export const {featureName}Schema = z.object({
  // TODO: Add validation rules
});

export type {FeatureName}Input = z.infer<typeof {featureName}Schema>;
```

**model/use{FeatureName}.ts**:
```typescript
// Generated by fsd-component-creation skill
import { useState } from 'react';
import type { {FeatureName}FormData, {FeatureName}Result } from './types';
import { {featureName}Schema } from './schema';

export function use{FeatureName}() {
  const [isLoading, setIsLoading] = useState(false);

  const handle{FeatureName} = async (data: {FeatureName}FormData): Promise<{FeatureName}Result> => {
    try {
      // Validate
      const validated = {featureName}Schema.parse(data);

      setIsLoading(true);

      // TODO: Implement business logic

      return { ok: true };
    } catch (error) {
      return { ok: false, error: String(error) };
    } finally {
      setIsLoading(false);
    }
  };

  return {
    handle{FeatureName},
    isLoading,
  };
}
```

**ui/{FeatureName}Form.tsx**:
```typescript
// Generated by fsd-component-creation skill
import { use{FeatureName} } from '../model/use{FeatureName}';

interface Props {
  // TODO: Domain data props only (NO event handlers)
}

export function {FeatureName}Form(props: Props) {
  const { handle{FeatureName}, isLoading } = use{FeatureName}();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // TODO: Collect form data and call handle{FeatureName}
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* TODO: Implement form UI */}
      <button type="submit" disabled={isLoading}>
        {isLoading ? '처리중...' : '제출'}
      </button>
    </form>
  );
}
```

#### Widget 템플릿

**ui/{WidgetName}.tsx**:
```typescript
// Generated by fsd-component-creation skill
interface Props {
  // TODO: Domain data props only (or no props)
}

export function {WidgetName}(props: Props) {
  return (
    <div>
      {/* TODO: Compose Features and Entities */}
    </div>
  );
}
```

#### Page 템플릿

**ui/{PageName}Page.tsx**:
```typescript
// Generated by fsd-component-creation skill
export function {PageName}Page() {
  return (
    <div>
      {/* TODO: Compose Widgets and Features */}
    </div>
  );
}
```

### Step 4: FSD 규칙 검증

생성된 컴포넌트가 FSD 규칙을 준수하는지 자동 검증합니다:

**Entity 검증**:
- ✅ No useState, useEffect
- ✅ No API calls
- ✅ No global state access
- ✅ Pure presentational components

**Features 검증**:
- ✅ Props are domain data only
- ✅ No event handler props (onSubmit, onChange, etc.)
- ✅ Business logic in hooks
- ✅ Self-contained user action

**Widgets 검증**:
- ✅ Minimal own logic
- ✅ Composes Features/Entities
- ✅ Independent UI block

**의존성 방향 검증**:
```
pages → widgets → features → entities → shared
```

### Step 5: 타입 체크

생성 완료 후 자동으로 타입 체크를 실행합니다:

```bash
yarn type-check
```

타입 에러 발견 시 자동 수정을 시도합니다.

## 사용 예시

### 예시 1: Entity 생성

**사용자 요청**: "Vehicle Entity를 만들어줘. 차량 종류, 톤수, 차량번호를 포함해야 해"

**실행**:
1. Layer 결정: Entity
2. Slice 생성: `src/entities/vehicle/`
3. 파일 생성:
   - `model/types.ts` (Vehicle 인터페이스)
   - `model/schema.ts` (vehicleSchema with Zod)
   - `ui/VehicleCard.tsx` (순수 프레젠테이션)
4. FSD 규칙 검증
5. 타입 체크

### 예시 2: Feature 생성

**사용자 요청**: "운송 신청 Feature를 추가해줘. 차량 정보, 주소, 일정을 입력받아야 해"

**실행**:
1. Layer 결정: Features
2. Slice 생성: `src/features/dispatch/`
3. 파일 생성:
   - `model/types.ts` (DispatchFormData)
   - `model/schema.ts` (dispatchSchema)
   - `model/useDispatchForm.ts` (비즈니스 로직 훅)
   - `api/createDispatch.ts` (API 호출)
   - `api/useCreateDispatch.ts` (React Query 훅)
   - `ui/DispatchForm.tsx` (훅 기반 폼)
4. FSD 규칙 검증 (Props에 이벤트 핸들러 없는지)
5. 타입 체크

### 예시 3: Widget 생성

**사용자 요청**: "Header Widget을 만들어줘. 로고, 사용자 정보, 알림을 표시해야 해"

**실행**:
1. Layer 결정: Widgets
2. Slice 생성: `src/widgets/header/`
3. 파일 생성:
   - `ui/Header.tsx` (Features/Entities 조합)
4. Import 검증 (Features/Entities만 import하는지)
5. 타입 체크

## 참고 파일

상세한 레이어별 규칙과 템플릿은 다음 파일을 참조하세요:

- **templates/entity-template.md**: Entity 컴포넌트 템플릿
- **templates/feature-template.md**: Feature 컴포넌트 템플릿
- **templates/widget-template.md**: Widget 컴포넌트 템플릿
- **templates/page-template.md**: Page 컴포넌트 템플릿
- **reference/layer-rules.md**: 레이어별 상세 규칙
- **reference/props-guidelines.md**: Props 사용 가이드라인

## 보고 형식

```markdown
## ✅ FSD 컴포넌트 생성 완료

### Layer
Entity

### Slice
src/entities/vehicle/

### 생성된 파일
- model/types.ts (Vehicle, VehicleCardProps)
- model/schema.ts (vehicleSchema)
- ui/VehicleCard.tsx (순수 프레젠테이션)

### FSD 규칙 검증
- ✅ Entity 순수성 유지
- ✅ Props 규칙 준수
- ✅ 의존성 방향 정상

### 타입 체크
✅ 타입 에러 없음

### 다음 단계
1. VehicleCard 컴포넌트에 실제 UI 구현
2. 필요시 VehicleInfo 등 추가 UI 컴포넌트 생성
3. Features에서 VehicleCard 활용
```

## 주의 사항

1. **Entity는 항상 순수하게**: useState, useEffect, API 호출 금지
2. **Features는 도메인 데이터만**: Props에 이벤트 핸들러 전달 금지 (shared/ui 제외)
3. **Widgets는 조합만**: 복잡한 로직은 Features로 분리
4. **의존성 방향 준수**: 상위 레이어만 하위 레이어 import
5. **Shared/UI는 예외**: 재사용 UI 컴포넌트는 이벤트 핸들러 props 허용

## 에러 처리

### 에러 1: Entity에서 훅 사용 감지

```markdown
❌ FSD 규칙 위반

Entity Layer에서 useState를 사용할 수 없습니다.

**위반 코드**:
entities/vehicle/ui/VehicleCard.tsx:10
const [selected, setSelected] = useState(false);

**수정 방안**:
상태 관리가 필요하면 Feature로 이동하세요.
features/vehicle/ui/VehicleCardContainer.tsx에서 훅을 사용하고,
entities/vehicle/ui/VehicleCard.tsx는 순수 props만 받도록 수정하세요.
```

### 에러 2: Feature Props에 이벤트 핸들러 감지

```markdown
❌ FSD 규칙 위반

Features Layer Props에 이벤트 핸들러를 전달할 수 없습니다.

**위반 코드**:
features/dispatch/ui/DispatchForm.tsx
interface Props {
  onSubmit: () => void;  // ❌
}

**수정 방안**:
Props는 도메인 데이터만 받고, 이벤트 핸들러는 내부에서 정의하세요.

interface Props {
  userId: string;  // ✅
}

export function DispatchForm({ userId }: Props) {
  const handleSubmit = () => { ... };  // 내부 정의
}
```

## 통합

이 Skill은 다음과 함께 사용됩니다:
- **fsd-architect** Sub-agent: 생성 후 아키텍처 규칙 재검증
- **test-guardian** Sub-agent: Major 워크플로우에서 테스트 파일 함께 생성
- **api-designer** Sub-agent: API 관련 Feature 생성 시 API 계약 먼저 설계
